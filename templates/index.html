
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RetroArch Analysis Stream</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body data-theme="dark">
    <button
      class="floating-action"
      type="button"
      aria-label="External information"
      title="External information"
    >
      <img
        src="data:image/png;base64,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"
        alt="external information"
      />
    </button>
    <main>
      <header class="page-header">
        <div class="page-header__top">
          <h1>RetroArch Analysis Stream</h1>
          <button
            id="theme-toggle"
            class="theme-toggle"
            type="button"
            aria-label="Switch to light mode"
            aria-pressed="false"
          >
            <span data-theme-toggle-label>Switch to light mode</span>
          </button>
        </div>
        <p>Live Pokémon battle analyses and summaries generated by the capture loop.</p>
      </header>

      <section class="panel" id="pokedex-panel">
        <div class="panel-heading">
          <h2>Pokédex</h2>
        </div>
        <div id="pokedex" class="accordion"></div>
        <template id="poke-card-template">
          <details class="poke-card">
            <summary>
              <div class="poke-card-header">
                <div class="poke-card-title">
                  <span class="poke-name" data-field="name"></span>
                  <span class="poke-types" data-field="types"></span>
                </div>
                <time class="poke-updated" data-field="updated"></time>
              </div>
            </summary>
            <div class="poke-card-body">
              <div class="poke-meta">
                <div class="metric">
                  <span class="metric-label">Height</span>
                  <span class="metric-value" data-field="height"></span>
                </div>
                <div class="metric">
                  <span class="metric-label">Weight</span>
                  <span class="metric-value" data-field="weight"></span>
                </div>
              </div>
              <div class="stat-grid">
                <div class="stat">
                  <span class="stat-label">HP</span>
                  <span class="stat-value" data-stat="hp"></span>
                </div>
                <div class="stat">
                  <span class="stat-label">Attack</span>
                  <span class="stat-value" data-stat="attack"></span>
                </div>
                <div class="stat">
                  <span class="stat-label">Defense</span>
                  <span class="stat-value" data-stat="defense"></span>
                </div>
                <div class="stat">
                  <span class="stat-label">Sp. Atk</span>
                  <span class="stat-value" data-stat="special-attack"></span>
                </div>
                <div class="stat">
                  <span class="stat-label">Sp. Def</span>
                  <span class="stat-value" data-stat="special-defense"></span>
                </div>
                <div class="stat">
                  <span class="stat-label">Speed</span>
                  <span class="stat-value" data-stat="speed"></span>
                </div>
              </div>
              <p class="list-line">
                <span class="list-label">Abilities</span>
                <span class="list-value" data-field="abilities"></span>
              </p>
              <p class="list-line">
                <span class="list-label">Weaknesses</span>
                <span class="list-value" data-field="weaknesses"></span>
              </p>
            </div>
          </details>
        </template>
      </section>

      <section class="panel">
        <div class="panel-heading">
          <h2>PokéAPI Chat</h2>
          <span id="chat-status" class="status-pill">Ready</span>
        </div>
        <div id="chat-container" class="chat-container">
          <label class="chat-tts-toggle">
            <input type="checkbox" id="chat-tts-toggle" />
            <span>Auto play summaries (every 10 frames)</span>
          </label>
          <div id="chat-messages" class="chat-messages"></div>
          <div class="chat-input-container">
            <input type="text" id="chat-input" placeholder="Ask about Pokémon..." />
            <button id="chat-send">Send</button>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panel-heading">
          <h2>Summaries</h2>
          <span id="summary-status" class="status-pill">Connecting…</span>
        </div>
        <div id="summary-stream" class="stream"></div>
      </section>
    </main>

    <script>
      const themeToggle = document.getElementById('theme-toggle');
      const themeToggleLabel = themeToggle ? themeToggle.querySelector('[data-theme-toggle-label]') : null;
      const analysisContainer = document.getElementById('analysis-stream');
      const summaryContainer = document.getElementById('summary-stream');
      const analysisStatus = document.getElementById('analysis-status');
      const summaryStatus = document.getElementById('summary-status');
      const pokedexContainer = document.getElementById('pokedex');
      const pokedexTemplate = document.getElementById('poke-card-template');
      const chatInput = document.getElementById('chat-input');
      const chatSend = document.getElementById('chat-send');
      const chatMessages = document.getElementById('chat-messages');
      const chatStatus = document.getElementById('chat-status');
      const chatTtsToggle = document.getElementById('chat-tts-toggle');

      const THEME_STORAGE_KEY = 'ui.theme.v1';
      const POKEDEX_STORAGE_KEY = 'pokedex.v1';
      const CHAT_TTS_STORAGE_KEY = 'chat.tts.autoplay.v1';
      const MAX_POKEDEX_ENTRIES = 30;
      const POKEDEX_DISPLAY_STATS = ['hp', 'attack', 'defense', 'special-attack', 'special-defense', 'speed'];
      const summaryAudioPlayer = new Audio();
      summaryAudioPlayer.preload = 'auto';
      let autoPlaySummaries = false;

      const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
      let activeTheme = resolveInitialTheme();
      applyTheme(activeTheme);

      if (themeToggle) {
        themeToggle.addEventListener('click', handleThemeToggle);
      }

      if (typeof prefersDarkScheme.addEventListener === 'function') {
        prefersDarkScheme.addEventListener('change', (event) => {
          if (getStoredTheme() !== null) {
            return;
          }
          applyTheme(event.matches ? 'dark' : 'light');
        });
      } else if (typeof prefersDarkScheme.addListener === 'function') {
        prefersDarkScheme.addListener((event) => {
          if (getStoredTheme() !== null) {
            return;
          }
          applyTheme(event.matches ? 'dark' : 'light');
        });
      }

      if (chatTtsToggle) {
        try {
          const stored = localStorage.getItem(CHAT_TTS_STORAGE_KEY);
          if (stored === 'true' || stored === 'false') {
            chatTtsToggle.checked = stored === 'true';
          }
        } catch (err) {
          console.warn('Failed to read chat TTS preference', err);
        }
        autoPlaySummaries = chatTtsToggle.checked;
        chatTtsToggle.addEventListener('change', () => {
          autoPlaySummaries = chatTtsToggle.checked;
          try {
            localStorage.setItem(CHAT_TTS_STORAGE_KEY, autoPlaySummaries ? 'true' : 'false');
          } catch (err) {
            console.warn('Failed to persist chat TTS preference', err);
          }
        });
      }

      let pokedexStore = loadPokedex();
      let expandedPokedexEntry = getMostRecentEntry(pokedexStore);

      function handleThemeToggle() {
        const next = activeTheme === 'dark' ? 'light' : 'dark';
        applyTheme(next);
        persistThemePreference(next);
      }

      function applyTheme(theme) {
        activeTheme = theme === 'light' ? 'light' : 'dark';
        if (document.body) {
          document.body.dataset.theme = activeTheme;
        }
        updateThemeToggle();
      }

      function updateThemeToggle() {
        if (!themeToggle) {
          return;
        }
        const nextModeLabel = activeTheme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
        themeToggle.setAttribute('aria-pressed', activeTheme === 'dark' ? 'true' : 'false');
        themeToggle.setAttribute('aria-label', nextModeLabel);
        themeToggle.title = nextModeLabel;
        if (themeToggleLabel) {
          themeToggleLabel.textContent = nextModeLabel;
        } else {
          themeToggle.textContent = nextModeLabel;
        }
      }

      function resolveInitialTheme() {
        const stored = getStoredTheme();
        if (stored) {
          return stored;
        }
        return prefersDarkScheme.matches ? 'dark' : 'light';
      }

      function getStoredTheme() {
        try {
          const stored = localStorage.getItem(THEME_STORAGE_KEY);
          if (stored === 'light' || stored === 'dark') {
            return stored;
          }
        } catch (err) {
          console.warn('Failed to read theme preference', err);
        }
        return null;
      }

      function persistThemePreference(theme) {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, theme);
        } catch (err) {
          console.warn('Failed to persist theme preference', err);
        }
      }

      function normaliseName(name) {
        return (name || '').trim().toLowerCase();
      }

      function titleCase(name) {
        return (name || '').replace(/[-_]/g, ' ').replace(/\b\w/g, (char) => char.toUpperCase());
      }

      function loadPokedex() {
        try {
          const raw = localStorage.getItem(POKEDEX_STORAGE_KEY);
          if (!raw) {
            return {};
          }
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === 'object') {
            return parsed;
          }
        } catch (err) {
          console.warn('Failed to parse Pokédex cache', err);
        }
        return {};
      }

      function persistPokedex(store) {
        try {
          localStorage.setItem(POKEDEX_STORAGE_KEY, JSON.stringify(store));
        } catch (err) {
          console.warn('Failed to persist Pokédex cache', err);
        }
      }

      function getMostRecentEntry(store) {
        const entries = Object.entries(store || {});
        if (!entries.length) {
          return null;
        }
        entries.sort(([, a], [, b]) => new Date(b.lastSeen || 0) - new Date(a.lastSeen || 0));
        return entries[0][0];
      }

      function sortEntriesByRecency(store) {
        return Object.entries(store || {}).sort(([, a], [, b]) => new Date(b.lastSeen || 0) - new Date(a.lastSeen || 0));
      }

      function formatHeight(height) {
        if (typeof height !== 'number') {
          return '—';
        }
        const meters = height / 10;
        return `${height} dm (${meters.toFixed(1)} m)`;
      }

      function formatWeight(weight) {
        if (typeof weight !== 'number') {
          return '—';
        }
        const kilograms = weight / 10;
        return `${weight} hg (${kilograms.toFixed(1)} kg)`;
      }

      function formatList(values) {
        if (!Array.isArray(values) || !values.length) {
          return '—';
        }
        return values.map((value) => titleCase(value)).join(', ');
      }

      function renderPokedex() {
        if (!pokedexContainer || !pokedexTemplate) {
          return;
        }

        pokedexContainer.innerHTML = '';

        const entries = sortEntriesByRecency(pokedexStore);
        if (!entries.length) {
          return;
        }

        entries.slice(0, MAX_POKEDEX_ENTRIES).forEach(([key, data]) => {
          const fragment = pokedexTemplate.content.cloneNode(true);
          const card = fragment.querySelector('.poke-card');
          if (!card) {
            return;
          }

          card.dataset.name = key;

          if (expandedPokedexEntry === null) {
            expandedPokedexEntry = key;
          }

          card.open = key === expandedPokedexEntry;

          const nameField = fragment.querySelector('[data-field="name"]');
          const typesField = fragment.querySelector('[data-field="types"]');
          const updatedField = fragment.querySelector('[data-field="updated"]');
          const heightField = fragment.querySelector('[data-field="height"]');
          const weightField = fragment.querySelector('[data-field="weight"]');
          const abilitiesField = fragment.querySelector('[data-field="abilities"]');
          const weaknessesField = fragment.querySelector('[data-field="weaknesses"]');

          if (nameField) {
            const displayName = data.displayName || titleCase(data.name || key);
            nameField.textContent = displayName;
          }

          if (typesField) {
            typesField.textContent = formatList(data.types);
          }

          if (updatedField) {
            updatedField.textContent = data.lastSeen ? new Date(data.lastSeen).toLocaleTimeString() : '';
            if (data.lastSeen) {
              updatedField.dateTime = data.lastSeen;
            }
          }

          if (heightField) {
            heightField.textContent = formatHeight(data.height);
          }

          if (weightField) {
            weightField.textContent = formatWeight(data.weight);
          }

          if (abilitiesField) {
            abilitiesField.textContent = formatList(data.abilities);
          }

          if (weaknessesField) {
            weaknessesField.textContent = formatList(data.weaknesses);
          }

          POKEDEX_DISPLAY_STATS.forEach((statKey) => {
            const statField = fragment.querySelector(`[data-stat="${statKey}"]`);
            if (statField) {
              const stats = data.base_stats || {};
              const value = stats[statKey];
              statField.textContent = typeof value === 'number' ? value : '—';
            }
          });

          card.addEventListener('toggle', () => {
            if (card.open) {
              expandedPokedexEntry = key;
              closeSiblingCards(key);
            }
          });

          pokedexContainer.appendChild(fragment);
        });
      }

      function closeSiblingCards(activeKey) {
        pokedexContainer.querySelectorAll('.poke-card').forEach((node) => {
          if (node.dataset.name !== activeKey) {
            node.open = false;
          }
        });
      }

      function upsertPokedexEntry(name, payload) {
        const key = normaliseName(name);
        if (!key) {
          return;
        }

        if (!payload || typeof payload !== 'object' || payload.error) {
          return;
        }

        const nextStore = { ...pokedexStore };
        const existing = nextStore[key] || {};
        const merged = {
          ...existing,
          ...payload,
          name: payload.name || name,
          lastSeen: new Date().toISOString(),
        };

        nextStore[key] = merged;

        const ordered = sortEntriesByRecency(nextStore);
        if (ordered.length > MAX_POKEDEX_ENTRIES) {
          ordered.slice(MAX_POKEDEX_ENTRIES).forEach(([staleKey]) => {
            delete nextStore[staleKey];
          });
        }

        pokedexStore = nextStore;
        expandedPokedexEntry = key;
        persistPokedex(pokedexStore);
        renderPokedex();
      }

      function applyLatestCalls(latestCalls) {
        if (!Array.isArray(latestCalls)) {
          return;
        }
        latestCalls.forEach((entry) => {
          const payload = entry && typeof entry === 'object' ? entry.data : null;
          const names = Array.isArray(entry && entry.names) ? entry.names : [];
          if (!payload || payload.error) {
            return;
          }
          const canonicalName = payload.name || names[0];
          if (canonicalName) {
            upsertPokedexEntry(canonicalName, {
              ...payload,
              displayName: titleCase(payload.name || canonicalName),
            });
          } else {
            names.forEach((rawName) => {
              upsertPokedexEntry(rawName, payload);
            });
          }
        });
      }

      renderPokedex();

      function trimChildren(container, limit = 50) {
        while (container.children.length > limit) {
          container.removeChild(container.lastChild);
        }
      }

      function setStatus(statusEl, text, tone) {
        if (!statusEl) {
          return;
        }
        statusEl.textContent = text;
        statusEl.dataset.tone = tone;
      }

      function resolveStaticUrl(path) {
        if (!path) {
          return null;
        }
        if (path.startsWith('http://') || path.startsWith('https://')) {
          return path;
        }
        return path.startsWith('/') ? path : `/${path}`;
      }

      function playSummaryAudioIfEnabled(payload) {
        if (!autoPlaySummaries) {
          return;
        }
        const audioPath = payload && payload.summary_audio;
        if (!audioPath) {
          return;
        }
        const resolved = resolveStaticUrl(audioPath);
        if (!resolved) {
          return;
        }
        try {
          summaryAudioPlayer.pause();
        } catch (err) {
          // ignore pause errors
        }
        summaryAudioPlayer.currentTime = 0;
        summaryAudioPlayer.src = `${resolved}?t=${Date.now()}`;
        summaryAudioPlayer.play().catch(() => {});
      }

      function attachStream(url, handler, statusEl) {
        const source = new EventSource(url);
        source.onmessage = handler;
        source.onopen = () => setStatus(statusEl, 'Connected', 'ok');
        source.onerror = () => setStatus(statusEl, 'Reconnecting…', 'warn');
        return source;
      }

      function renderAnalysis(event) {
        const payload = JSON.parse(event.data);

        if (payload.meta && payload.meta.latest_calls) {
          applyLatestCalls(payload.meta.latest_calls);
        }

        if (!analysisContainer) {
          return;
        }

        const item = document.createElement('article');
        item.className = 'stream-item';

        const header = document.createElement('div');
        header.className = 'stream-header';
        const badge = document.createElement('span');
        badge.className = 'badge';

        if (payload.type === 'analysis') {
          badge.textContent = `Frame ${payload.capture_index ?? '?'}`;
          header.appendChild(badge);
          const ts = document.createElement('span');
          ts.textContent = payload.timestamp || '';
          header.appendChild(ts);
          item.appendChild(header);

          const statusLine = document.createElement('p');
          statusLine.className = 'status-line';
          const battleStatus = payload.meta && payload.meta.battle_detected ? 'Battle detected' : 'Not a battle';
          const toolStatus = payload.meta && payload.meta.tool_called ? 'PokéAPI call complete' : 'No tool calls';
          statusLine.textContent = `${battleStatus} • ${toolStatus}`;
          item.appendChild(statusLine);

          if (payload.meta && payload.meta.participants && payload.meta.participants.length) {
            const participants = document.createElement('p');
            participants.className = 'participants';
            participants.textContent = `Participants: ${payload.meta.participants.join(' vs. ')}`;
            item.appendChild(participants);
          }

        } else if (payload.type === 'analysis_error') {
          badge.textContent = 'Error';
          badge.classList.add('error');
          header.appendChild(badge);
          const ts = document.createElement('span');
          ts.textContent = payload.timestamp || '';
          header.appendChild(ts);
          item.appendChild(header);

          const message = document.createElement('p');
          message.className = 'status-line';
          message.textContent = payload.message || 'Analysis error';
          item.appendChild(message);

          if (payload.raw) {
            const rawBlock = document.createElement('pre');
            rawBlock.textContent = payload.raw;
            item.appendChild(rawBlock);
          }

          item.classList.add('error');
        }

        analysisContainer.prepend(item);
        trimChildren(analysisContainer);
      }

      function renderSummary(event) {
        const payload = JSON.parse(event.data);
        const item = document.createElement('article');
        item.className = 'stream-item summary';

        const header = document.createElement('div');
        header.className = 'stream-header';
        const badge = document.createElement('span');
        badge.className = 'badge summary';
        badge.textContent = 'Summary';
        header.appendChild(badge);
        const ts = document.createElement('span');
        ts.textContent = payload.timestamp || '';
        header.appendChild(ts);
        item.appendChild(header);

        const body = document.createElement('p');
        body.textContent = payload.summary || '';
        item.appendChild(body);

        summaryContainer.prepend(item);
        trimChildren(summaryContainer, 20);
        playSummaryAudioIfEnabled(payload);
      }

      // Chat functionality
      async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message) return;
        
        // Add user message to chat
        addMessage(message, 'user');
        chatInput.value = '';
        
        // Update status
        setStatus(chatStatus, 'Thinking...', 'warn');
        
        try {
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
          });
          
          const data = await response.json();
          if (data.error) {
            addMessage(`Error: ${data.error}`, 'error');
          } else {
            addMessage(data.response, 'assistant');
          }
          setStatus(chatStatus, 'Ready', 'ok');
        } catch (error) {
          addMessage('Sorry, there was an error processing your request.', 'error');
          setStatus(chatStatus, 'Error', 'error');
        }
      }

      function addMessage(content, type) {
        const messageEl = document.createElement('div');
        messageEl.className = `chat-message ${type}`;
        messageEl.textContent = content;
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Chat event listeners
      if (chatSend) {
        chatSend.addEventListener('click', sendMessage);
      }
      
      if (chatInput) {
        chatInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            sendMessage();
          }
        });
      }

      attachStream('/stream/analysis', renderAnalysis, analysisStatus);
      attachStream('/stream/summaries', renderSummary, summaryStatus);
    </script>
  </body>
</html>
